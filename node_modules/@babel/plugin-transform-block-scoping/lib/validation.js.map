{"version":3,"names":["_core","require","validateUsage","path","state","tdzEnabled","dynamicTDZNames","name","Object","keys","getBindingIdentifiers","binding","scope","getBinding","injectTDZChecks","push","node","kind","disallowConstantViolations","violation","constantViolations","readOnlyError","addHelper","throwNode","t","callExpression","stringLiteral","isAssignmentExpression","operator","left","right","exprs","replaceWith","sequenceExpression","includes","logicalExpression","slice","binaryExpression","isUpdateExpression","unaryExpression","get","isForXStatement","ensureBlock","variableDeclaration","variableDeclarator","generateUidIdentifier","body","unshift","expressionStatement","getTDZStatus","refPath","bindingPath","executionStatus","_guessExecutionStatusRelativeTo","skipTDZChecks","WeakSet","buildTDZAssert","status","clone","cloneNode","add","getTDZReplacement","id","_path$scope$getBindin","has","isFunctionDeclaration","parent","_tdzThis","allUsages","Set","referencePaths","forEach","dynamicTdz","arg","replacement","insertBefore","nodes","ids","length","parentPath","isFor"],"sources":["../src/validation.ts"],"sourcesContent":["import { types as t } from \"@babel/core\";\nimport type { Scope, NodePath, PluginPass } from \"@babel/core\";\n\nexport function validateUsage(\n  path: NodePath<t.VariableDeclaration>,\n  state: PluginPass,\n  tdzEnabled: boolean,\n) {\n  const dynamicTDZNames = [];\n\n  for (const name of Object.keys(path.getBindingIdentifiers())) {\n    const binding = path.scope.getBinding(name);\n    // binding may be null. ref: https://github.com/babel/babel/issues/15300\n    if (!binding) continue;\n    if (tdzEnabled) {\n      if (injectTDZChecks(binding, state)) dynamicTDZNames.push(name);\n    }\n    if (path.node.kind === \"const\") {\n      disallowConstantViolations(name, binding, state);\n    }\n  }\n\n  return dynamicTDZNames;\n}\n\nfunction disallowConstantViolations(\n  name: string,\n  binding: Scope.Binding,\n  state: PluginPass,\n) {\n  for (const violation of binding.constantViolations) {\n    const readOnlyError = state.addHelper(\"readOnlyError\");\n    const throwNode = t.callExpression(readOnlyError, [t.stringLiteral(name)]);\n\n    if (violation.isAssignmentExpression()) {\n      const { operator, left, right } = violation.node;\n      if (operator === \"=\") {\n        const exprs = [right];\n        exprs.push(throwNode);\n        violation.replaceWith(t.sequenceExpression(exprs));\n      } else if ([\"&&=\", \"||=\", \"??=\"].includes(operator)) {\n        violation.replaceWith(\n          t.logicalExpression(\n            // @ts-expect-error todo: give a better type to operator\n            operator.slice(0, -1),\n            left,\n            t.sequenceExpression([right, throwNode]),\n          ),\n        );\n      } else {\n        violation.replaceWith(\n          t.sequenceExpression([\n            t.binaryExpression(\n              // @ts-expect-error todo: give a better type to operator\n              operator.slice(0, -1),\n              left,\n              right,\n            ),\n            throwNode,\n          ]),\n        );\n      }\n    } else if (violation.isUpdateExpression()) {\n      violation.replaceWith(\n        t.sequenceExpression([\n          t.unaryExpression(\"+\", violation.get(\"argument\").node),\n          throwNode,\n        ]),\n      );\n    } else if (violation.isForXStatement()) {\n      violation.ensureBlock();\n      violation\n        .get(\"left\")\n        .replaceWith(\n          t.variableDeclaration(\"var\", [\n            t.variableDeclarator(violation.scope.generateUidIdentifier(name)),\n          ]),\n        );\n      (violation.node.body as t.BlockStatement).body.unshift(\n        t.expressionStatement(throwNode),\n      );\n    }\n  }\n}\n\nfunction getTDZStatus(refPath: NodePath, bindingPath: NodePath) {\n  const executionStatus = bindingPath._guessExecutionStatusRelativeTo(refPath);\n\n  if (executionStatus === \"before\") {\n    return \"outside\";\n  } else if (executionStatus === \"after\") {\n    return \"inside\";\n  } else {\n    return \"maybe\";\n  }\n}\n\nconst skipTDZChecks = new WeakSet();\n\nfunction buildTDZAssert(\n  status: \"maybe\" | \"inside\",\n  node: t.Identifier | t.JSXIdentifier,\n  state: PluginPass,\n) {\n  if (status === \"maybe\") {\n    const clone = t.cloneNode(node);\n    skipTDZChecks.add(clone);\n    return t.callExpression(state.addHelper(\"temporalRef\"), [\n      // @ts-expect-error Fixme: we may need to handle JSXIdentifier\n      clone,\n      t.stringLiteral(node.name),\n    ]);\n  } else {\n    return t.callExpression(state.addHelper(\"tdz\"), [\n      t.stringLiteral(node.name),\n    ]);\n  }\n}\n\ntype TDZReplacement = { status: \"maybe\" | \"inside\"; node: t.Expression };\nfunction getTDZReplacement(\n  path: NodePath<t.Identifier | t.JSXIdentifier>,\n  state: PluginPass,\n): TDZReplacement | undefined;\nfunction getTDZReplacement(\n  path: NodePath,\n  state: PluginPass,\n  id: t.Identifier | t.JSXIdentifier,\n): TDZReplacement | undefined;\nfunction getTDZReplacement(\n  path: NodePath,\n  state: PluginPass,\n  id: t.Identifier | t.JSXIdentifier = path.node as any,\n): TDZReplacement | undefined {\n  if (skipTDZChecks.has(id)) return;\n  skipTDZChecks.add(id);\n\n  const bindingPath = path.scope.getBinding(id.name)?.path;\n\n  if (!bindingPath || bindingPath.isFunctionDeclaration()) return;\n\n  const status = getTDZStatus(path, bindingPath);\n  if (status === \"outside\") return;\n\n  if (status === \"maybe\") {\n    // add tdzThis to parent variable declarator so it's exploded\n    // @ts-expect-error todo(